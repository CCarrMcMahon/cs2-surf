from enum import StrEnum
import pathlib
from pathlib import Path
from ambuild2.frontend.v2_2.context import BuildContext
from ambuild2.frontend.v2_2.cpp.compiler import CliCompiler
from ambuild2.frontend.v2_2.tools.protoc import Protoc, ProtocJob


class CompilerAttrs(StrEnum):
    INCLUDES = "includes"
    CXX_INCLUDES = "cxxincludes"
    C_FLAGS = "cflags"
    CXX_FLAGS = "cxxflags"
    DEFINES = "defines"
    CXX_DEFINES = "cxxdefines"
    C_ONLY_FLAGS = "c_only_flags"
    RC_DEFINES = "rcdefines"
    LINK_FLAGS = "linkflags"
    POST_LINK = "postlink"
    SOURCE_DEPS = "sourcedeps"
    WEAK_LINK_DEPS = "weaklinkdeps"
    LINK_DEPS = "linkdeps"


class MetamodSourcePlugin:
    """A class with variables and functions related to the plugin."""

    context: BuildContext
    plugin_name: str
    plugin_alias: str
    root_path: Path
    mms_path: Path
    hl2sdk_path: Path
    game_name: str
    compiler: CliCompiler
    protoc_job: ProtocJob

    def __init__(self, context: BuildContext) -> None:
        self.context = context
        self.root_path = pathlib.Path(context.sourcePath).resolve()
        self.__parse_context_options()
        # self.set_compiler()
        # self.compiler_set_defaults()

    def __parse_context_options(self) -> None:
        """A private helper method to parse custom plugin arguments."""
        plugin_name: str = self.context.options.plugin_name
        plugin_alias: str = self.context.options.plugin_alias
        mms_path_str: str = self.context.options.mms_path
        hl2sdk_path_str: str = self.context.options.hl2sdk_path
        game_name: str = self.context.options.game_name

        plugin_name = plugin_name.strip()
        plugin_alias = plugin_alias.strip()
        mms_path_str = mms_path_str.strip()
        hl2sdk_path_str = hl2sdk_path_str.strip()
        game_name = game_name.strip()

        if plugin_name == "":
            raise ValueError("The name of the plugin can't be empty.")

        if mms_path_str == "":
            raise ValueError("The path to the Metamod:Source directory can't be empty.")

        if hl2sdk_path_str == "":
            raise ValueError("The path to the HL2SDK directory can't be empty.")

        mms_path = pathlib.Path(mms_path_str)
        hl2sdk_path = pathlib.Path(hl2sdk_path_str)

        if not mms_path.is_absolute():
            mms_path = self.root_path.joinpath(mms_path).resolve()

        if not hl2sdk_path.is_absolute():
            hl2sdk_path = self.root_path.joinpath(hl2sdk_path).resolve()

        if game_name == "":
            if hl2sdk_path.name.find("-") == -1:
                raise ValueError("The name of the game can't be empty and not in the HL2SDK path.")
            game_name = hl2sdk_path.name.split("-")[-1].strip()

        if not mms_path.exists():
            raise FileNotFoundError(f'The Metamod:Source path "{mms_path}" doesn\'t exist.')

        if not mms_path.is_dir():
            raise NotADirectoryError(f'The Metamod:Source path "{mms_path}" must be a directory.')

        if not hl2sdk_path.exists():
            hl2sdk_path = pathlib.Path(f"{hl2sdk_path}-{game_name}").resolve()
            if not hl2sdk_path.exists():
                raise FileNotFoundError(f'The HL2SDK path "{hl2sdk_path}" doesn\'t exist.')

            if not hl2sdk_path.is_dir():
                raise NotADirectoryError(f'The HL2SDK path "{hl2sdk_path}" must be a directory.')

        self.plugin_name = plugin_name
        self.plugin_alias = plugin_alias
        self.mms_path = mms_path
        self.hl2sdk_path = hl2sdk_path
        self.game_name = game_name

    def set_compiler(self, platform="", arch="", abi="") -> None:
        """A method to set the compiler that will be used for the plugin.

        Currently, only Windows x86_64 MSVC is supported.
        """
        platform = platform.lower().strip()  # Platform not supported by AMBuild
        arch = arch.lower().strip()
        abi = abi.lower().strip()
        args = [platform, arch, abi]

        compiler: CliCompiler = None
        if all((s == "") for s in args):
            compiler = self.context.DetectCxx()
        else:
            target = "-".join([s for s in args if s != ""])
            compiler = self.context.DetectCxx(target=target)

        if compiler.target.platform != "windows":
            raise SystemExit("This plugin currently only supports being built on Windows.")

        if compiler.target.arch != "x86_64":
            raise SystemExit("This plugin currently only supports being built on x86_64.")

        if compiler.vendor.name != "msvc":
            raise SystemExit("This plugin currently only supports being built with MSVC.")

        self.compiler = compiler

    def compiler_set_attrs(self, attr_name: CompilerAttrs, *args: str) -> None:
        """Sets a list of string arguments to a compiler attribute."""
        value = []
        value.extend([str(arg) for arg in args])
        setattr(self.compiler, attr_name, value)

    def compiler_add_attrs(self, attr_name: CompilerAttrs, *args: str) -> None:
        """Adds a list of string arguments to a compiler attribute."""
        value: list[str] = getattr(self.compiler, attr_name)
        value.extend([str(arg) for arg in args])
        setattr(self.compiler, attr_name, value)

    def compiler_add_debug(self) -> None:
        """A debug related attributes to the compiler."""
        self.compiler_add_attrs(CompilerAttrs.C_FLAGS, "/MTd", "/Od", "/RTC1")
        self.compiler_add_attrs(CompilerAttrs.DEFINES, "DEBUG", "_DEBUG")
        self.compiler_add_attrs(CompilerAttrs.LINK_FLAGS, "/NODEFAULTLIB:libcmt")

    def compiler_add_optimization(self) -> None:
        """A optimization related attributes to the compiler."""
        self.compiler_add_attrs(CompilerAttrs.C_FLAGS, "/Ox", "/Zo")
        self.compiler_add_attrs(CompilerAttrs.DEFINES, "NDEBUG")
        self.compiler_add_attrs(CompilerAttrs.LINK_FLAGS, "/OPT:ICF", "/OPT:REF")

    def compiler_set_defaults(self) -> None:
        """Clears compiler attributes and sets default values."""
        # Clear attributes
        for attr_name in CompilerAttrs:
            self.compiler_set_attrs(attr_name)

        # Add debug related attributes
        if self.debug:
            self.compiler_add_debug()
        else:
            self.compiler_add_attrs(CompilerAttrs.C_FLAGS, "/MT")

        # Add optimization related attributes
        if self.optimize:
            self.compiler_add_optimization()

        # Add standard attributes
        self.compiler_add_attrs(CompilerAttrs.C_FLAGS, "/W3", "/Zi", "/std:c++17", "/Oy-")
        self.compiler_add_attrs(CompilerAttrs.CXX_FLAGS, "/TP")
        self.compiler_add_attrs(
            CompilerAttrs.DEFINES,
            "_CRT_SECURE_NO_DEPRECATE",
            "_CRT_SECURE_NO_WARNINGS",
            "_CRT_NONSTDC_NO_DEPRECATE",
            "WIN32",
            "_WINDOWS",
        )
        self.compiler_add_attrs(
            CompilerAttrs.LINK_FLAGS,
            "/SUBSYSTEM:WINDOWS",
            "kernel32.lib",
            "user32.lib",
            "gdi32.lib",
            "winspool.lib",
            "comdlg32.lib",
            "advapi32.lib",
            "shell32.lib",
            "ole32.lib",
            "oleaut32.lib",
            "uuid.lib",
            "odbc32.lib",
            "odbccp32.lib",
        )

        # TODO: Add needed sdk includes

    def compiler_display_attrs(self) -> None:
        """Display the value of all compiler attributes."""
        for attr_name in CompilerAttrs:
            print(f"{attr_name}: {getattr(self.compiler, attr_name)}")


plugin = MetamodSourcePlugin(builder)

# ROOT_DIR_PATH = pathlib.Path(plugin.context.sourcePath).resolve()
# METAMOD_SOURCE_PATH = ROOT_DIR_PATH.joinpath("metamod-source").resolve()
# HL2SDK_CS2_PATH = ROOT_DIR_PATH.joinpath("hl2sdk-cs2").resolve()

# # Needed by metamod
# plugin.compiler_add_attrs(
#     CompilerAttrs.CXX_INCLUDES,
#     METAMOD_SOURCE_PATH.joinpath("core").resolve(),
#     METAMOD_SOURCE_PATH.joinpath("core", "sourcehook").resolve(),
#     HL2SDK_CS2_PATH.joinpath("common").resolve(),
#     HL2SDK_CS2_PATH.joinpath("public").resolve(),
#     HL2SDK_CS2_PATH.joinpath("public", "tier0").resolve(),
#     HL2SDK_CS2_PATH.joinpath("public", "tier1").resolve(),
#     HL2SDK_CS2_PATH.joinpath("thirdparty", "protobuf-3.21.8", "src").resolve(),
# )

# plugin.compiler_add_attrs(
#     CompilerAttrs.DEFINES,
#     "COMPILER_MSVC",
#     "COMPILER_MSVC64",
#     "META_IS_SOURCE2",
#     "PLATFORM_64BITS",
#     "SOURCE_ENGINE=25"
# )

# plugin.compiler_add_attrs(
#     CompilerAttrs.LINK_FLAGS,
#     HL2SDK_CS2_PATH.joinpath("lib", "public", "win64", "2015", "libprotobuf.lib").resolve(),
#     HL2SDK_CS2_PATH.joinpath("lib", "public", "win64", "interfaces.lib").resolve(),
#     HL2SDK_CS2_PATH.joinpath("lib", "public", "win64", "tier0.lib").resolve(),
#     HL2SDK_CS2_PATH.joinpath("lib", "public", "win64", "tier1.lib").resolve(),
# )

# # Protocs
# protoc_path = HL2SDK_CS2_PATH.joinpath("devtools", "bin", "protoc.exe")
# protoc: Protoc = plugin.context.DetectProtoc(path=str(protoc_path))
# protoc.includes += [
#     HL2SDK_CS2_PATH.joinpath("thirdparty", "protobuf-3.21.8", "src").resolve(),
#     HL2SDK_CS2_PATH.joinpath("common").resolve(),
# ]
# protoc_job = plugin.context.tools.Protoc(
#     protoc=protoc, sources=[str(HL2SDK_CS2_PATH.joinpath("common", "network_connection.proto"))]
# )

# # Create library
# binary = plugin.compiler.Library(plugin.name)
# binary.sources += [
#     str(pathlib.Path(plugin.context.sourcePath, "src", "sample_mm.cpp").resolve()),
#     str(HL2SDK_CS2_PATH.joinpath("tier1", "convar.cpp").resolve()),
#     str(HL2SDK_CS2_PATH.joinpath("public", "tier0", "memoverride.cpp").resolve()),
# ]
# binary.custom += [protoc_job]
# cpp_node = plugin.context.Add(binary)
