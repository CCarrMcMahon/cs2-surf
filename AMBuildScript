from enum import StrEnum
import pathlib
from pathlib import Path
from ambuild2.frontend.v2_2.context import BuildContext
from ambuild2.frontend.v2_2.cpp.compiler import CliCompiler
from ambuild2.frontend.v2_2.tools.protoc import Protoc


class CompilerAttrs(StrEnum):
    INCLUDES = "includes"
    CXX_INCLUDES = "cxxincludes"
    C_FLAGS = "cflags"
    CXX_FLAGS = "cxxflags"
    DEFINES = "defines"
    CXX_DEFINES = "cxxdefines"
    C_ONLY_FLAGS = "c_only_flags"
    RC_DEFINES = "rcdefines"
    LINK_FLAGS = "linkflags"
    POST_LINK = "postlink"
    SOURCE_DEPS = "sourcedeps"
    WEAK_LINK_DEPS = "weaklinkdeps"
    LINK_DEPS = "linkdeps"


class MetamodSourcePlugin:
    """A class with variables and functions related to the plugin."""

    context: BuildContext
    name: str
    alias: str
    debug: bool
    optimize: bool
    compiler: CliCompiler

    def __init__(self, context: BuildContext) -> None:
        self.context = context
        self.__parse_context_options()
        self.set_compiler()
        # self.compiler_set_defaults()

    def __parse_context_options(self) -> None:
        """A private helper method to parse custom plugin arguments."""
        name: str = self.context.options.plugin_name
        alias: str = self.context.options.plugin_alias
        debug: bool = self.context.options.debug
        optimize: bool = self.context.options.optimize

        name = name.strip()
        alias = alias.strip()

        if name == "":
            raise ValueError("The name of the plugin can't be empty.")

        self.name = name
        self.alias = alias
        self.debug = debug
        self.optimize = optimize

    def set_compiler(self, platform="", arch="", abi="") -> None:
        """A method to set the compiler that will be used for the plugin.

        Currently, only Windows x86_64 MSVC is supported.
        """
        platform = platform.lower().strip()  # Platform not supported by AMBuild
        arch = arch.lower().strip()
        abi = abi.lower().strip()
        args = [platform, arch, abi]

        compiler: CliCompiler = None
        if all((s == "") for s in args):
            compiler = self.context.DetectCxx()
        else:
            target = "-".join([s for s in args if s != ""])
            compiler = self.context.DetectCxx(target=target)

        if compiler.target.platform != "windows":
            raise SystemExit("This plugin currently only supports being built on Windows.")

        if compiler.target.arch != "x86_64":
            raise SystemExit("This plugin currently only supports being built on x86_64.")

        if compiler.vendor.name != "msvc":
            raise SystemExit("This plugin currently only supports being built with MSVC.")

        self.compiler = compiler

    def compiler_set_attrs(self, attr_name: CompilerAttrs, *args: str) -> None:
        """Sets a list of string arguments to a compiler attribute."""
        value = []
        value.extend([str(arg) for arg in args])
        setattr(self.compiler, attr_name, value)

    def compiler_add_attrs(self, attr_name: CompilerAttrs, *args: str) -> None:
        """Adds a list of string arguments to a compiler attribute."""
        value: list[str] = getattr(self.compiler, attr_name)
        value.extend([str(arg) for arg in args])
        setattr(self.compiler, attr_name, value)

    def compiler_add_debug(self) -> None:
        """A debug related attributes to the compiler."""
        self.compiler_add_attrs(CompilerAttrs.C_FLAGS, "/MTd", "/Od", "/RTC1")
        self.compiler_add_attrs(CompilerAttrs.DEFINES, "DEBUG", "_DEBUG")
        self.compiler_add_attrs(CompilerAttrs.LINK_FLAGS, "/NODEFAULTLIB:libcmt")

    def compiler_add_optimization(self) -> None:
        """A optimization related attributes to the compiler."""
        self.compiler_add_attrs(CompilerAttrs.C_FLAGS, "/Ox", "/Zo")
        self.compiler_add_attrs(CompilerAttrs.DEFINES, "NDEBUG")
        self.compiler_add_attrs(CompilerAttrs.LINK_FLAGS, "/OPT:ICF", "/OPT:REF")

    def compiler_set_defaults(self) -> None:
        """Clears compiler attributes and sets default values."""
        # Clear attributes
        for attr_name in CompilerAttrs:
            self.compiler_set_attrs(attr_name)

        # Add debug related attributes
        if self.debug:
            self.compiler_add_debug()
        else:
            self.compiler_add_attrs(CompilerAttrs.C_FLAGS, "/MT")

        # Add optimization related attributes
        if self.optimize:
            self.compiler_add_optimization()

        # Add standard attributes
        self.compiler_add_attrs(CompilerAttrs.C_FLAGS, "/W3", "/Zi", "/std:c++17", "/Oy-")
        self.compiler_add_attrs(CompilerAttrs.CXX_FLAGS, "/TP")
        self.compiler_add_attrs(
            CompilerAttrs.DEFINES,
            "_CRT_SECURE_NO_DEPRECATE",
            "_CRT_SECURE_NO_WARNINGS",
            "_CRT_NONSTDC_NO_DEPRECATE",
            "WIN32",
            "_WINDOWS",
        )
        self.compiler_add_attrs(
            CompilerAttrs.LINK_FLAGS,
            "/SUBSYSTEM:WINDOWS",
            "kernel32.lib",
            "user32.lib",
            "gdi32.lib",
            "winspool.lib",
            "comdlg32.lib",
            "advapi32.lib",
            "shell32.lib",
            "ole32.lib",
            "oleaut32.lib",
            "uuid.lib",
            "odbc32.lib",
            "odbccp32.lib",
        )

        # TODO: Add needed sdk includes

    def compiler_display_attrs(self) -> None:
        """Display the value of all compiler attributes."""
        for attr_name in CompilerAttrs:
            print(f"{attr_name}: {getattr(self.compiler, attr_name)}")


plugin = MetamodSourcePlugin(builder)

ROOT_DIR_PATH = pathlib.Path(plugin.context.sourcePath).resolve()
METAMOD_SOURCE_PATH = ROOT_DIR_PATH.joinpath("metamod-source").resolve()
HL2SDK_CS2_PATH = ROOT_DIR_PATH.joinpath("hl2sdk-cs2").resolve()

# Needed by metamod
plugin.compiler_add_attrs(
    CompilerAttrs.CXX_INCLUDES,
    METAMOD_SOURCE_PATH.joinpath("core").resolve(),
    METAMOD_SOURCE_PATH.joinpath("core", "sourcehook").resolve(),
    HL2SDK_CS2_PATH.joinpath("common").resolve(),
    HL2SDK_CS2_PATH.joinpath("public").resolve(),
    HL2SDK_CS2_PATH.joinpath("public", "tier0").resolve(),
    HL2SDK_CS2_PATH.joinpath("public", "tier1").resolve(),
    HL2SDK_CS2_PATH.joinpath("thirdparty", "protobuf-3.21.8", "src").resolve(),
)

plugin.compiler_add_attrs(
    CompilerAttrs.DEFINES, "COMPILER_MSVC", "COMPILER_MSVC64", "META_IS_SOURCE2", "PLATFORM_64BITS", "SOURCE_ENGINE=25"
)

plugin.compiler_add_attrs(
    CompilerAttrs.LINK_FLAGS,
    HL2SDK_CS2_PATH.joinpath("lib", "public", "win64", "2015", "libprotobuf.lib").resolve(),
    HL2SDK_CS2_PATH.joinpath("lib", "public", "win64", "interfaces.lib").resolve(),
    HL2SDK_CS2_PATH.joinpath("lib", "public", "win64", "tier0.lib").resolve(),
    HL2SDK_CS2_PATH.joinpath("lib", "public", "win64", "tier1.lib").resolve(),
)

# Protocs
protoc_path = HL2SDK_CS2_PATH.joinpath("devtools", "bin", "protoc.exe")
protoc: Protoc = plugin.context.DetectProtoc(path=str(protoc_path))
protoc.includes += [
    HL2SDK_CS2_PATH.joinpath("thirdparty", "protobuf-3.21.8", "src").resolve(),
    HL2SDK_CS2_PATH.joinpath("common").resolve(),
]
protoc_job = plugin.context.tools.Protoc(
    protoc=protoc, sources=[str(HL2SDK_CS2_PATH.joinpath("common", "network_connection.proto"))]
)

# Create library
binary = plugin.compiler.Library(plugin.name)
binary.sources += [
    str(pathlib.Path(plugin.context.sourcePath, "src", "sample_mm.cpp").resolve()),
    str(HL2SDK_CS2_PATH.joinpath("tier1", "convar.cpp").resolve()),
    str(HL2SDK_CS2_PATH.joinpath("public", "tier0", "memoverride.cpp").resolve()),
]
binary.custom += [protoc_job]
cpp_node = plugin.context.Add(binary)
