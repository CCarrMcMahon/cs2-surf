from enum import StrEnum
import pathlib
from pathlib import Path
from ambuild2.frontend.v2_2.context import BuildContext
from ambuild2.frontend.v2_2.cpp.builders import BinaryBuilder
from ambuild2.frontend.v2_2.cpp.compiler import CliCompiler
from ambuild2.frontend.v2_2.tools.protoc import Protoc, ProtocJob


# TODO: Support multiple binaries by allow list to be created and context based compiler
# TODO: Add packaging functionality
# TODO: Dynamically parse from manifest files
# TODO: Add AMBuilder and PackageScript


class CompilerAttrs(StrEnum):
    INCLUDES = "includes"
    CXX_INCLUDES = "cxxincludes"
    C_FLAGS = "cflags"
    CXX_FLAGS = "cxxflags"
    DEFINES = "defines"
    CXX_DEFINES = "cxxdefines"
    C_ONLY_FLAGS = "c_only_flags"
    RC_DEFINES = "rcdefines"
    LINK_FLAGS = "linkflags"
    POST_LINK = "postlink"
    SOURCE_DEPS = "sourcedeps"
    WEAK_LINK_DEPS = "weaklinkdeps"
    LINK_DEPS = "linkdeps"


class MetamodSourcePlugin:
    """A class with variables and functions related to the plugin."""

    context: BuildContext
    plugin_name: str
    plugin_alias: str
    root_path: Path
    mms_path: Path
    hl2sdk_path: Path
    game_name: str
    compiler: CliCompiler
    protoc_job: ProtocJob
    binary: BinaryBuilder

    def __init__(self, context: BuildContext) -> None:
        self.context = context
        self.root_path = pathlib.Path(context.sourcePath).resolve()
        self.__parse_context_options()
        self.set_compiler()
        self.set_protoc()
        self.set_binary()
        self.compiler_set_defaults()
        self.protoc_set_defaults()
        self.binary_set_defaults()
        self.add_binaries()
        self.compiler_display_attrs()
        print(self.protoc_job.sources)
        print(self.protoc_job.protoc.includes)
        print(self.binary.sources)
        print(self.binary.custom)

    def get_path(self, *args: str) -> Path:
        return pathlib.Path(*args).resolve()

    def get_path_from_root(self, *args: str) -> Path:
        return self.get_path(self.root_path, *args)

    def get_path_from_mss(self, *args: str) -> Path:
        return self.get_path(self.mms_path, *args)

    def get_path_from_hl2sdk(self, *args: str) -> Path:
        return self.get_path(self.hl2sdk_path, *args)

    def __parse_context_options(self) -> None:
        """A private helper method to parse custom plugin arguments."""
        plugin_name: str = self.context.options.plugin_name
        plugin_alias: str = self.context.options.plugin_alias
        mms_path_str: str = self.context.options.mms_path
        hl2sdk_path_str: str = self.context.options.hl2sdk_path
        game_name: str = self.context.options.game_name

        plugin_name = plugin_name.strip()
        plugin_alias = plugin_alias.strip()
        mms_path_str = mms_path_str.strip()
        hl2sdk_path_str = hl2sdk_path_str.strip()
        game_name = game_name.strip()

        if plugin_name == "":
            raise ValueError("The name of the plugin can't be empty.")

        if mms_path_str == "":
            raise ValueError("The path to the Metamod:Source directory can't be empty.")

        if hl2sdk_path_str == "":
            raise ValueError("The path to the HL2SDK directory can't be empty.")

        mms_path = pathlib.Path(mms_path_str)
        hl2sdk_path = pathlib.Path(hl2sdk_path_str)

        if not mms_path.is_absolute():
            mms_path = self.get_path_from_root(mms_path)

        if not hl2sdk_path.is_absolute():
            hl2sdk_path = self.get_path_from_root(hl2sdk_path)

        if game_name == "":
            if hl2sdk_path.name.find("-") == -1:
                raise ValueError("The name of the game can't be empty and not in the HL2SDK path.")
            game_name = hl2sdk_path.name.split("-")[-1].strip()

        if not mms_path.exists():
            raise FileNotFoundError(f'The Metamod:Source path "{mms_path}" doesn\'t exist.')

        if not mms_path.is_dir():
            raise NotADirectoryError(f'The Metamod:Source path "{mms_path}" must be a directory.')

        if not hl2sdk_path.exists():
            hl2sdk_path = pathlib.Path(f"{hl2sdk_path}-{game_name}").resolve()
            if not hl2sdk_path.exists():
                raise FileNotFoundError(f'The HL2SDK path "{hl2sdk_path}" doesn\'t exist.')

            if not hl2sdk_path.is_dir():
                raise NotADirectoryError(f'The HL2SDK path "{hl2sdk_path}" must be a directory.')

        self.plugin_name = plugin_name
        self.plugin_alias = plugin_alias
        self.mms_path = mms_path
        self.hl2sdk_path = hl2sdk_path
        self.game_name = game_name

    def set_compiler(self, platform="", arch="", abi="") -> None:
        """A method to set the compiler that will be used for the plugin.

        Currently, only Windows x86_64 MSVC is supported.
        """
        platform = platform.lower().strip()  # Platform not supported by AMBuild
        arch = arch.lower().strip()
        abi = abi.lower().strip()
        args = [platform, arch, abi]

        compiler: CliCompiler = None
        if all((s == "") for s in args):
            compiler = self.context.DetectCxx()
        else:
            target = "-".join([s for s in args if s != ""])
            compiler = self.context.DetectCxx(target=target)

        if compiler.target.platform != "windows":
            raise SystemExit("This plugin currently only supports being built on Windows.")

        if compiler.target.arch != "x86_64":
            raise SystemExit("This plugin currently only supports being built on x86_64.")

        if compiler.vendor.name != "msvc":
            raise SystemExit("This plugin currently only supports being built with MSVC.")

        self.compiler = compiler

    def compiler_set_attrs(self, attr_name: CompilerAttrs, *args: str) -> None:
        """Sets a list of string arguments to a compiler attribute."""
        value = [str(arg) for arg in args]
        setattr(self.compiler, attr_name, value)

    def compiler_add_attrs(self, attr_name: CompilerAttrs, *args: str) -> None:
        """Adds a list of string arguments to a compiler attribute."""
        value: list[str] = getattr(self.compiler, attr_name)
        value.extend([str(arg) for arg in args])
        setattr(self.compiler, attr_name, value)

    def compiler_display_attrs(self) -> None:
        """Display the value of all compiler attributes."""
        for attr_name in CompilerAttrs:
            print(f"{attr_name}: {getattr(self.compiler, attr_name)}")

    def set_protoc(self) -> None:
        protoc_path = self.get_path_from_hl2sdk("devtools", "bin", "protoc.exe")
        if not protoc_path.exists():
            raise FileNotFoundError(f'Unable to find protoc.exe at "{protoc_path}".')
        protoc: Protoc = self.context.DetectProtoc(path=str(protoc_path))
        self.protoc_job = self.context.tools.Protoc(protoc)

    def protoc_set_sources(self, *args: str) -> None:
        self.protoc_job.sources = [str(arg) for arg in args]

    def protoc_add_sources(self, *args: str) -> None:
        self.protoc_job.sources.extend([str(arg) for arg in args])

    def protoc_set_includes(self, *args: str) -> None:
        self.protoc_job.protoc.includes = [str(arg) for arg in args]

    def protoc_add_includes(self, *args: str) -> None:
        self.protoc_job.protoc.includes.extend([str(arg) for arg in args])

    def set_binary(self) -> None:
        """Create a binary from the compiler and the plugin name."""
        self.binary = self.compiler.Library(self.plugin_name)
        self.compiler = self.binary.compiler

    def binary_set_sources(self, *args: str) -> None:
        self.binary.sources = [str(arg) for arg in args]

    def binary_add_sources(self, *args: str) -> None:
        self.binary.sources.extend([str(arg) for arg in args])

    def binary_set_custom(self, *args: object) -> None:
        self.binary.custom = list(args)

    def binary_add_custom(self, *args: object) -> None:
        self.binary.custom.extend(list(args))

    def compiler_set_defaults(self) -> None:
        """Clears compiler attributes and sets default values."""
        # Clear attributes
        for attr_name in CompilerAttrs:
            self.compiler_set_attrs(attr_name)

        self.compiler_add_attrs(
            CompilerAttrs.DEFINES,
            "COMPILER_MSVC",
            "COMPILER_MSVC64",
            "PLATFORM_64BITS",
            "META_IS_SOURCE2",
            "SOURCE_ENGINE=25",
        )

        self.compiler_add_attrs(
            CompilerAttrs.CXX_INCLUDES,
            self.get_path_from_mss("core"),
            self.get_path_from_mss("core", "sourcehook"),
            self.get_path_from_hl2sdk("common"),
            self.get_path_from_hl2sdk("public"),
            self.get_path_from_hl2sdk("public", "tier0"),
            self.get_path_from_hl2sdk("public", "tier1"),
            self.get_path_from_hl2sdk("thirdparty", "protobuf-3.21.8", "src"),
        )

        self.compiler_add_attrs(
            CompilerAttrs.LINK_FLAGS,
            self.get_path_from_hl2sdk("lib", "public", "win64", "2015", "libprotobuf.lib"),
            self.get_path_from_hl2sdk("lib", "public", "win64", "interfaces.lib"),
            self.get_path_from_hl2sdk("lib", "public", "win64", "tier0.lib"),
            self.get_path_from_hl2sdk("lib", "public", "win64", "tier1.lib"),
        )

    def protoc_set_defaults(self) -> None:
        """Initialize the protoc with the needed default values."""
        self.protoc_set_includes(
            self.get_path_from_hl2sdk("thirdparty", "protobuf-3.21.8", "src"), self.get_path_from_hl2sdk("common")
        )
        self.protoc_set_sources(self.get_path_from_hl2sdk("common", "network_connection.proto"))

    def binary_set_defaults(self) -> None:
        """Initialize the binaries with the needed default values."""
        self.binary_set_sources(
            self.get_path_from_root("src", "sample_mm.cpp"),
            self.get_path_from_hl2sdk("tier1", "convar.cpp"),
            self.get_path_from_hl2sdk("public", "tier0", "memoverride.cpp"),
        )
        self.binary_set_custom(self.protoc_job)

    def add_binaries(self) -> None:
        """Add a list of binaries to the current context."""
        cpp_node = self.context.Add(self.binary)


plugin = MetamodSourcePlugin(builder)
